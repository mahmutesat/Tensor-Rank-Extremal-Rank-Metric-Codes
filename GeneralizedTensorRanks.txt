LoadPackage("fining");
#############################################################################
#Given a Vector, It Creates a Matrix of the Given Sizes
#############################################################################
CreateMatrix := function(vector, row, column)
	local Matrix, j;
	Matrix := List( [1..row], j -> vector{ [1+(column)*(j-1)..column*j] });
	return Matrix;
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Creates The Generators of the Group That Stabilizes the Set of Rank-1 Matrices
#############################################################################
ActOnBasis := function(D, Space)
	local BasissOfSpace, GeneratorsOfD, prG, prH, resultmatrices, groupelement, matrix, resultbasis, i, newbasiselement; 
	
	BasissOfSpace := ShallowCopy(Basis(Space));
	GeneratorsOfD := GeneratorsOfMagmaWithInverses(D);
	prG := Projection(D,1);
	prH := Projection(D,2);
	
	#Let the generators of D=GxH act on the basis of the Tensor 
	#and create their Matrix Representations
	resultmatrices := [];
	for groupelement in GeneratorsOfD do
		matrix := [];
		resultbasis := Image(prG,groupelement)*BasissOfSpace*TransposedMat(Image(prH,groupelement));
		#resultbasis := Filtered(resultbasis, i -> i in Tensor);
		
		for newbasiselement in resultbasis do
			Add(matrix, Coefficients(Basis(Space), newbasiselement));
		od;
		Add(resultmatrices, matrix);
	od;

	return resultmatrices;
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Using the Function "ActOnBasis", Generates the Group
#############################################################################
MatrixGroup := function(q,N1,N2)
	local G, H, DP, V, GeneratorsOfGroup, result;

	#Groups
	G := GL(N1, q);
	H := GL(N2, q); 
	DP := DirectProduct(G,H);
	V:= FullMatrixSpace(GF(q),N1,N2);
	
	#Matrix Group
	GeneratorsOfGroup := ActOnBasis(DP, V);
	result := Group(GeneratorsOfGroup);

	return result;
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Projectifies the Matrix Group Generated by the Function "MatrixGroup"
#############################################################################
ProjectiveMatrixGroup:=function(q,N1,N2)
	local MatGroup, GeneratorsOfGroup, pg, ProjectivitiesOfTheGeneratorsOfGroup, generator;
	
	MatGroup := MatrixGroup(q,N1,N2);
	GeneratorsOfGroup := GeneratorsOfMagmaWithInverses(MatGroup);
	pg := PG(N1*N2-1,q);
	
	ProjectivitiesOfTheGeneratorsOfGroup := [];
	for generator in GeneratorsOfGroup do
		Add(ProjectivitiesOfTheGeneratorsOfGroup, Projectivity(pg,generator));
	od;

	return Group(ProjectivitiesOfTheGeneratorsOfGroup);
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Flats the Whole Code
#############################################################################
FlatTheCode := function(C)
	local N1, N2, Generators, k, F, V;
	N1 := DimensionOfVectors(C)[1];
	N2 := DimensionOfVectors(C)[2];
	Generators := List(Basis(C), i-> Flat(i));
	k := N1*N2;
	F := LeftActingDomain(C);
	V := F^k;
	return Subspace(V,Generators);
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Projectifies the Given Code C
#############################################################################	
ProjectifyTheCode := function(C)
	local N1, N2, q, pg, BasisOfCode;
	
	N1 := DimensionOfVectors(C)[1];
	N2 := DimensionOfVectors(C)[2];
	q := Size(LeftActingDomain(C));
	pg := PG(N1*N2-1,q);
	BasisOfCode := List(Basis(C),i->Flat(i));

	return VectorSpaceToElement(pg,BasisOfCode);
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#This Function is Used in the Function "DataForGTR"
#############################################################################	
CheckEmpty := function(list)
	if IsEmpty(list)=true then
		return [0];
	else
		return [1];
	fi;
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Given a List of Equivalence Classes, Returns Combined Orbits of All Equivalence Classes
#############################################################################	
CreateOrbits := function(H, D)
	local Orbits, i;
	
	Orbits := [];
	for i in D do
		if not i=[] then
			Append(Orbits,FiningOrbits(H,i));
		fi;
	od;

	return Orbits;
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#This Function is Used in the Inductive Step of the Function "DataForGTR"
#############################################################################	
CreateTheObjectsOfTheNextLevel := function(PointsOfSegreVar, Orbits)
	local Representativess, ObjectsOfTheNextLevel, rep, NewPointsOfSegreVar, NewObjects;
	
	#Choose Representatives From Orbits
	Representativess := List(Orbits, i->i[1]);
	
	#Create The Next Level
	ObjectsOfTheNextLevel := [];
	for rep in Representativess do
		NewPointsOfSegreVar := Filtered(PointsOfSegreVar, x-> not x in rep);
		NewObjects := List(NewPointsOfSegreVar, x-> Span(x,rep));
		Append(ObjectsOfTheNextLevel, NewObjects);
	od;

	return ObjectsOfTheNextLevel;
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Returns the Data For Generalized Tensor Ranks and Minimum Subspace That Contains the Code
#############################################################################	
DataForGTR := function(C, H)
	local DimensionOfTheCode, PC, N1, N2, F, q, SegreVar, PointsOfSegreVar, V, DimensionOfTheBigSpace, GeneralizedTensorRanks, IntersectionInfoForGTR, ResultingSpace, D, d, point, count, count2, j, Orbits, ObjectsOfTheNextLevel, object, k, Infoo, x, m, n;                         

	#Define The Parameters
	DimensionOfTheCode := Dimension(C);
	V := ParentAttr(C);
	DimensionOfTheBigSpace := Dimension(V);
	PC := ProjectifyTheCode(C);
	N1 := DimensionOfVectors(C)[1];
	N2 := DimensionOfVectors(C)[2];
	F := LeftActingDomain(C);
	q := Size(F);
	SegreVar := SegreVariety([PG(N1-1,q),PG(N2-1,q)]);
	PointsOfSegreVar := AsList(PointsOfSegreVariety(SegreVar));
	GeneralizedTensorRanks := [];
	IntersectionInfoForGTR := [[[],[]]];
	ResultingSpace := [];

	#Prepare the Levels
	D := [];
	for d in [1..DimensionOfTheBigSpace] do
		Add(D, List([1..d+1], i-> []));
	od;

	#Create the First Level, D_1
	for point in PointsOfSegreVar do
		if point in PC then
			Add(D[1][2],point);
		else 
			Add(D[1][1],point);
		fi;
	od;

	#Note the Intersection Info For the First Level
	if not D[1][1]=[] then
		Add(IntersectionInfoForGTR[1][1],1);
	else
		Add(IntersectionInfoForGTR[1][1],0);
	fi;
	if not D[1][2]=[] then
		Add(IntersectionInfoForGTR[1][2],1);
	else
		Add(IntersectionInfoForGTR[1][2],0);
	fi;

	#Create the Other Levels Inductively
	count := 0;
	count2 := 0;
	for j in [2..Length(D)] do
		Orbits := CreateOrbits(H, D[j-1-count2]);
		Remove(D,j-1-count2);
		count2 := count2+1;
		ObjectsOfTheNextLevel := CreateTheObjectsOfTheNextLevel(PointsOfSegreVar, Orbits);
		for object in ObjectsOfTheNextLevel do
			k := ProjectiveDimension(Meet(PC,object));
			if k = ProjectiveDimension(PC) then
				count := 1;
				Add(ResultingSpace, object);
			fi;
			Add(D[j-count2][k+2],object);
		od;
		Infoo := List(D[j-count2], CheckEmpty);
		Add(IntersectionInfoForGTR, Infoo);
		if count=1 then
			break;
		fi;
	od;


	#Collect The Information For The Generalized Tensor Rank
	for m in [1..DimensionOfTheCode] do
		if Length(GeneralizedTensorRanks)=DimensionOfTheCode then
			break;
		fi;
		for n in [m..Length(IntersectionInfoForGTR)] do
			if not IntersectionInfoForGTR[n][m+1]=[0] then
				Add(GeneralizedTensorRanks,n);
				break;
			fi;
		od;
	od;

	return [GeneralizedTensorRanks, ResultingSpace, PointsOfSegreVar];

end;		
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Returns the Generalized Tensor Ranks 
#############################################################################	
GTR := function(C,H)
	local Data;
	
	Data := DataForGTR(C,H);
	return Data[1];
end;
#############################################################################
#############################################################################
#############################################################################

#############################################################################
#Returns the Minimum Subspace That Contains the Code C
#############################################################################	
MinimumSubspace := function(C,H)
	local V, N1, N2, Data, ProjectiveSubspace, DimensionOfVectorSubspace, PointsOfSegreVar, PointsOfTheProjectiveSpace, Rank1Points, i, DesiredCombination, EveryCombination, combination, VectorSpaces, AsAList, Representatives, MatrixForm, MinSubspace;

	V := ParentAttr(C);
	N1 := DimensionOfVectors(C)[1];
	N2 := DimensionOfVectors(C)[2];
	Data := DataForGTR(C,H);
	ProjectiveSubspace := Data[2][1];
	DimensionOfVectorSubspace := ProjectiveDimension(ProjectiveSubspace) + 1;
	PointsOfSegreVar := Data[3];
	PointsOfTheProjectiveSpace := ShallowCopy(AsList(Points(ProjectiveSubspace)));
	
	#Remove Non-Rank1 Matrices From The Points
	Rank1Points := Filtered(PointsOfTheProjectiveSpace, i-> i in PointsOfSegreVar);
	
	#Find the Combination of Rank1Points That Spans ProjectiveSubspace
	DesiredCombination := 0;
	EveryCombination := UnorderedTuples(Rank1Points,DimensionOfVectorSubspace);
	for combination in EveryCombination do
		if Span(combination) = ProjectiveSubspace then
			DesiredCombination := combination;
			break;
		fi;
	od;
	
	#Create The Corresponding Vector Space
	VectorSpaces := List(DesiredCombination,point->UnderlyingVectorSpace(point));
	AsAList := List(VectorSpaces, i-> AsList(i));
	Representatives := List(AsAList, i-> ShallowCopy(i[2]));
	MatrixForm := List(Representatives, i->CreateMatrix(i, N1, N2));
	MinSubspace := Subspace(V,MatrixForm);

	return MinSubspace;
end;
#############################################################################
#############################################################################
#############################################################################